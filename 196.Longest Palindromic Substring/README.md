基本思想很简单当您将s增加1个字符时，您只能将maxPalindromeLen增加1或2，并且新的maxPalindrome包含此新字符。证明：如果添加1个字符，maxPalindromeLen增加3个或更多，说新的maxPalindromeLen是Q，并且旧的maxPalindromeLen是P，并且Q> = P + 3。那么这意味着，即使没有这个新角色，也会有一个回文子字符串结束于最后一个字符，其长度至少为Q-2。由于Q-2将为> P，所以这与P是没有附加字符的maxPalindromeLen的条件相矛盾。

所以，它变得简单，您只需要从头到尾扫描，一次添加一个字符，跟踪maxPalindromeLen，并且对于每个添加的字符，您检查以这个新字符结尾的子串，长度为P + 1或P + 2，是回文，并相应更新。

现在，时间复杂度为O（n ^ 2）算法似乎变为了O（n）。我们可以通过实现字符串是不可变的来加快它的速度，并且有内存切片技巧将有助于加速这些操作。将字符串“==”的时间复杂度是O（1），并且使用切片到子字符串和反向是O（n）。但是由于解码器的C代码优化了切片，所以应该运行得很快。我对Python很新非常感谢您提供更多见解或进一步的优化。
